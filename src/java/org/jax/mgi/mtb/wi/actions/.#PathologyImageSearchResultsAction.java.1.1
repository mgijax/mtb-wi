/**
 * Header: $Header$
 * Author: $Author$
 */
package org.jax.mgi.mtb.wi.actions;

import java.util.ArrayList;
import java.util.List;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.log4j.Logger;
import org.apache.struts.action.Action;
import org.apache.struts.action.ActionForm;
import org.apache.struts.action.ActionForward;
import org.apache.struts.action.ActionMapping;
import org.jax.mgi.mtb.dao.custom.SearchResults;
import org.jax.mgi.mtb.dao.custom.mtb.MTBPathologyImageSearchDTO;
import org.jax.mgi.mtb.dao.custom.mtb.MTBPathologyImageUtilDAO;
import org.jax.mgi.mtb.dao.custom.mtb.MTBReferenceUtilDAO;
import org.jax.mgi.mtb.utils.StringUtils;
import org.jax.mgi.mtb.utils.Timer;
import org.jax.mgi.mtb.wi.WIConstants;
import org.jax.mgi.mtb.wi.forms.PathologyImageSearchForm;
import org.jax.mgi.mtb.wi.utils.WIUtils;

/**
 * The PathologyImageSearchResultsAction class performs the search for
 * pathology images.
 *
 * @author $Author$
 * @date $Date$
 * @version $Revision$
 * @cvsheader $Header$
 * @see org.apache.struts.action.Action
 */
public class PathologyImageSearchResultsAction extends Action {

    // -------------------------------------------------------------- Constants
    // none

    // ----------------------------------------------------- Instance Variables

    private final static Logger log =
            Logger.getLogger(PathologyImageSearchResultsAction.class.getName());

    // ----------------------------------------------------------- Constructors
    // none

    // --------------------------------------------------------- Public Methods

    /**
     * The PathologyImageSearchResultsAction class performs the search for
     * pathology images.
     *
     * @param mapping the action mapping that determines where we need to go
     * @param form the form bean
     * @param request standard servlet request
     * @param response standard servlet response
     * @return the ActionForward object that indicates where to go
     * @throws Exception if the application business logic throws an exception.
     * @see org.apache.struts.action.ActionMapping
     * @see org.apache.struts.action.ActionForm
     * @see javax.servlet.http.HttpServletRequest
     * @see javax.servlet.http.HttpServletResponse
     */
    public ActionForward execute(ActionMapping mapping,
                                 ActionForm form,
                                 HttpServletRequest request,
                                 HttpServletResponse response)
        throws Exception {

        // default target to success
        String strTarget = "success";

        Timer timer = new Timer();
        timer.start();

        PathologyImageSearchForm formSearch = (PathologyImageSearchForm) form;
        String strSortBy = formSearch.getSortBy();
        String strMaxItems = formSearch.getMaxItems();
        String[] arrStrOrganTissuesOrigin = formSearch.getOrganTissueOrigin();
        List<String> arrOrganOrigin = new ArrayList<String>();
        String[] arrStrTumorClassifications =
                formSearch.getTumorClassification();
        List<String> arrTumorClass = new ArrayList<String>();
        String strReferenceKey = formSearch.getReferenceKey();
        String strAccId = null;
        String strMethod = formSearch.getMethod();
        String strMethodSelected = formSearch.getMethod();
        String[] arrStrAntibodies = formSearch.getAntibody();
        List<String> arrAntibodies = new ArrayList<String>();
        String strOrganAffected = formSearch.getOrganTissueAffected();
        
        long lMaxItems = WIUtils.stringToLong(strMaxItems, -1l);

        long lOrganAffectedKey = -1;

        try {
            lOrganAffectedKey = Integer.parseInt(strOrganAffected);
            strOrganAffected = WIConstants.getInstance().getOrgans().get(lOrganAffectedKey).getLabel();
        } catch (Exception e) {
            lOrganAffectedKey = -1;
        }

        long lReferenceKey = WIUtils.stringToLong(strReferenceKey, -1l);
  
        try {
            if (StringUtils.hasValue(strReferenceKey)) {
                // create a Reference DAO
                MTBReferenceUtilDAO dao = MTBReferenceUtilDAO.getInstance();

                // get the accession id
                strAccId = dao.getAccessionIdByReference(lReferenceKey);
            }
        } catch (Exception e) {
            log.error("Error retrieving accession id by reference", e);
        }

        arrOrganOrigin = WIUtils.arrayToCleanList(arrStrOrganTissuesOrigin);
        arrTumorClass = WIUtils.arrayToCleanList(arrStrTumorClassifications);
        arrAntibodies = WIUtils.arrayToCleanList(arrStrAntibodies);

        Timer daoTimer = new Timer();
        daoTimer.start();

        // perform the search
        // create a Pathology DAO
        MTBPathologyImageUtilDAO dao = MTBPathologyImageUtilDAO.getInstance();

        // create the collection of matching pathology images to return
        SearchResults<MTBPathologyImageSearchDTO> resPathImages = null;

        try {
            // search for the pathology images
            resPathImages = dao.searchPathology(arrOrganOrigin,
                                      arrTumorClass,
                                      (int)lOrganAffectedKey,
                                      null,
                                      strMethod, arrAntibodies,
                                      null,
                                      (int)lReferenceKey,
                                      strSortBy,
                                      (int)lMaxItems);
        } catch (Exception e) {
            log.error("Error searching for pathology images", e);
        }

        daoTimer.stop();

        if (log.isDebugEnabled()) {
            log.debug("PathologySearchResultsAction : DAO TIME: " +
                        daoTimer.toString());
        }

        if (resPathImages != null) {
            // put all the matching pathology images in the request
            request.setAttribute("pathologyImages",
                                 resPathImages.getList());
            request.setAttribute("numberOfResults",
                                 resPathImages.getSize() + "");
            request.setAttribute("totalNumOfPathImages",
                                 resPathImages.getAncillaryTotal() + "");
            request.setAttribute("totalResults",
                                 resPathImages.getTotal() + "");
        }

        request.setAttribute("organsAffectedSelected",
                             strOrganAffected);
        request.setAttribute("organOriginSelected",
                             WIUtils.organKeysToLabel(arrOrganOrigin));
        request.setAttribute("tumorClassificationsSelected",
                             WIUtils.tumorclassificationKeysToLabel(arrTumorClass));
        request.setAttribute("antibodiesSelected",
                             WIUtils.probeKeysToLabel(arrAntibodies));
        request.setAttribute("methodSelected", strMethodSelected);
        request.setAttribute("accId", strAccId);
        request.setAttribute("sortBy", StringUtils.initCap(strSortBy));
        request.setAttribute("maxItems", strMaxItems);

        timer.stop();

        if (log.isDebugEnabled()) {
            log.debug("PathologySearchResultsAction: " + timer.toString());
        }

        // forward to the appropriate View
        return mapping.findForward(strTarget);
    }

    // ------------------------------------------------------ Protected Methods
    // none

    // -------------------------------------------------------- Private Methods
    // none
}
